<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rush Hour Puzzle Generator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Lexend:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #FF2D55;
            --secondary: #FFD60A;
            --accent: #32ADE6;
            --dark: #1A1A2E;
            --grid-bg: #E8E8E8;
            --grid-line: #CCCCCC;
            --paper: #FFFEF9;
            --cell-size: calc(100% / 6);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Lexend', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 2rem;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background-image: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(255,255,255,0.03) 2px, rgba(255,255,255,0.03) 4px);
            pointer-events: none;
            z-index: 1;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            z-index: 2;
        }

        header {
            text-align: center;
            margin-bottom: 3rem;
            animation: slideDown 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-50px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h1 {
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(1.5rem, 4vw, 3rem);
            color: var(--secondary);
            text-shadow: 4px 4px 0 var(--primary), 8px 8px 0 rgba(0,0,0,0.2);
            margin-bottom: 1rem;
            letter-spacing: 2px;
            line-height: 1.4;
        }

        .subtitle {
            font-size: 1.1rem;
            color: rgba(255,255,255,0.9);
            font-weight: 300;
            letter-spacing: 1px;
        }

        .config-panel {
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 1.25rem 2rem;
            margin: 0 auto 1.5rem;
            max-width: 500px;
            animation: fadeIn 1s ease-out 0.2s backwards;
        }

        .config-row {
            display: flex;
            justify-content: center;
            gap: 2rem;
            flex-wrap: wrap;
        }

        .config-row label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: white;
            font-size: 0.95rem;
        }

        .config-label {
            font-weight: 500;
        }

        .config-row input[type="number"] {
            width: 60px;
            padding: 0.5rem;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            background: rgba(255,255,255,0.9);
            font-family: 'Lexend', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            text-align: center;
            color: var(--dark);
        }

        .config-row input[type="number"]:focus {
            outline: none;
            border-color: var(--secondary);
            box-shadow: 0 0 0 3px rgba(255,214,10,0.3);
        }

        .config-note {
            text-align: center;
            color: rgba(255,255,255,0.8);
            font-size: 0.85rem;
            margin-top: 0.75rem;
            font-style: italic;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            margin-bottom: 3rem;
            flex-wrap: wrap;
            animation: fadeIn 1s ease-out 0.3s backwards;
        }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        button {
            font-family: 'Lexend', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            padding: 1rem 2.5rem;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .generate-btn {
            background: var(--secondary);
            color: var(--dark);
            box-shadow: 0 6px 0 #C9AB08, 0 10px 20px rgba(0,0,0,0.3);
        }
        .generate-btn:hover { transform: translateY(-3px); box-shadow: 0 9px 0 #C9AB08, 0 14px 25px rgba(0,0,0,0.35); }
        .generate-btn:active { transform: translateY(3px); box-shadow: 0 3px 0 #C9AB08, 0 5px 12px rgba(0,0,0,0.25); }

        .print-btn {
            background: white;
            color: var(--dark);
            box-shadow: 0 6px 0 #C0C0C0, 0 10px 20px rgba(0,0,0,0.3);
        }
        .print-btn:hover { transform: translateY(-3px); box-shadow: 0 9px 0 #C0C0C0, 0 14px 25px rgba(0,0,0,0.35); }
        .print-btn:active { transform: translateY(3px); box-shadow: 0 3px 0 #C0C0C0, 0 5px 12px rgba(0,0,0,0.25); }

        .generating-msg {
            text-align: center;
            color: white;
            font-size: 1.2rem;
            padding: 2rem;
            animation: blink 1s ease-in-out infinite;
        }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }

        .cards-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 2rem;
        }

        .puzzle-card {
            background: var(--paper);
            border-radius: 20px;
            padding: 1.5rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2), inset 0 1px 0 rgba(255,255,255,0.5);
            position: relative;
            animation: cardPop 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) backwards;
        }

        .puzzle-card::before {
            content: '';
            position: absolute;
            top: 8px; left: 8px; right: 8px; bottom: 8px;
            border: 2px dashed var(--grid-line);
            border-radius: 15px;
            pointer-events: none;
        }

        @keyframes cardPop {
            from { opacity: 0; transform: scale(0.85); }
            to { opacity: 1; transform: scale(1); }
        }
        .puzzle-card:nth-child(1) { animation-delay: 0.1s; }
        .puzzle-card:nth-child(2) { animation-delay: 0.2s; }
        .puzzle-card:nth-child(3) { animation-delay: 0.3s; }
        .puzzle-card:nth-child(4) { animation-delay: 0.4s; }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            position: relative;
            z-index: 1;
        }

        .puzzle-number {
            font-family: 'Press Start 2P', cursive;
            font-size: 1.2rem;
            color: var(--primary);
            text-shadow: 2px 2px 0 var(--secondary);
        }

        .difficulty {
            color: white;
            padding: 0.4rem 0.8rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .difficulty.easy { background: #34C759; box-shadow: 0 3px 0 #28a745; }
        .difficulty.medium { background: #FF9500; box-shadow: 0 3px 0 #e08600; }
        .difficulty.hard { background: #FF2D55; box-shadow: 0 3px 0 #d4264a; }

        .moves-info {
            font-size: 0.8rem;
            color: #666;
            text-align: center;
            margin-top: 0.3rem;
            position: relative;
            z-index: 1;
        }

        /* --- THE GRID --- */
        .grid-wrapper {
            position: relative;
            z-index: 1;
            padding-right: 20px; /* space for exit arrow */
        }

        .grid-board {
            position: relative;
            width: 100%;
            padding-bottom: 100%; /* force square via padding trick */
            background: var(--dark);
            border-radius: 8px;
            overflow: hidden;
        }

        .grid-inner {
            position: absolute;
            top: 2px; left: 2px; right: 2px; bottom: 2px;
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            grid-template-rows: repeat(6, 1fr);
            gap: 2px;
        }

        .grid-cell {
            background: #F5F5F5;
            border-radius: 2px;
        }

        /* Exit notch on right side row 3 */
        .grid-board::after {
            content: '';
            position: absolute;
            right: -2px;
            top: calc(2px + (100% - 4px) * 2 / 6 + (100% - 4px) / 6 * 0.15);
            width: 6px;
            height: calc((100% - 4px) / 6 * 0.7);
            background: #F5F5F5;
            border-radius: 0 3px 3px 0;
        }

        .exit-arrow {
            position: absolute;
            right: 0;
            top: calc((100% - 20px) * 2 / 6 + (100% - 20px) / 12);
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 12px solid var(--primary);
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: translateY(-50%) translateX(0); }
            50% { opacity: 0.5; transform: translateY(-50%) translateX(4px); }
        }

        /* --- CARS (absolutely positioned inside grid-inner) --- */
        .car {
            position: absolute;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.7rem;
            color: white;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.3);
            box-shadow: inset 0 2px 4px rgba(255,255,255,0.35), inset 0 -2px 4px rgba(0,0,0,0.15), 0 2px 4px rgba(0,0,0,0.25);
            border: 1.5px solid rgba(0,0,0,0.15);
            z-index: 2;
            transition: filter 0.15s;
        }
        .car:hover { filter: brightness(1.1); }

        .car-red {
            background: linear-gradient(135deg, #FF2D55, #E01040);
            font-size: 0.85rem;
        }

        .legend {
            margin-top: 1rem;
            padding: 0.75rem;
            background: rgba(0,0,0,0.03);
            border-radius: 8px;
            position: relative;
            z-index: 1;
        }

        .legend-title {
            font-weight: 700;
            margin-bottom: 0.4rem;
            color: var(--dark);
            text-transform: uppercase;
            font-size: 0.75rem;
            letter-spacing: 0.5px;
        }

        .legend-items {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            font-size: 0.75rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .legend-swatch {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 1.5px solid rgba(0,0,0,0.15);
        }

        @media print {
            body { background: white; padding: 0.5rem; }
            body::before { display: none; }
            header, .controls, .config-panel { display: none; }
            .cards-grid { grid-template-columns: repeat(2, 1fr); gap: 1rem; }
            .puzzle-card { break-inside: avoid; box-shadow: none; border: 1px solid #ccc; padding: 1rem; }
            .exit-arrow { animation: none; }
        }

        @media (max-width: 768px) {
            .cards-grid { grid-template-columns: 1fr; }
            h1 { font-size: 1.3rem; }
        }
    </style>
</head>
<body>
<div class="container">
    <header>
        <h1>Rush Hour<br>Puzzle Generator</h1>
        <p class="subtitle">Solvable Puzzles with Your Car Collection</p>
    </header>

    <div class="config-panel">
        <div class="config-row">
            <label>
                <span class="config-label">Small Cars (2-cell):</span>
                <input type="number" id="smallCars" value="8" min="0" max="12">
            </label>
            <label>
                <span class="config-label">Trucks (3-cell):</span>
                <input type="number" id="bigCars" value="4" min="0" max="8">
            </label>
        </div>
        <p class="config-note">+ 1 Red Car (2-cell) always included</p>
    </div>

    <div class="controls">
        <button class="generate-btn" onclick="generatePuzzles()">Generate New Puzzles</button>
        <button class="print-btn" onclick="window.print()">Print Cards</button>
    </div>

    <div class="cards-grid" id="cardsGrid">
        <div class="generating-msg">Generating solvable puzzles...</div>
    </div>
</div>

<script>
// ── Color palette for cars ──────────────────────────────────────────
const PALETTE = [
    { name: 'blue',   bg: 'linear-gradient(135deg,#007AFF,#005EC4)' },
    { name: 'green',  bg: 'linear-gradient(135deg,#34C759,#28a745)' },
    { name: 'orange', bg: 'linear-gradient(135deg,#FF9500,#E08600)' },
    { name: 'purple', bg: 'linear-gradient(135deg,#AF52DE,#8E3FC0)' },
    { name: 'teal',   bg: 'linear-gradient(135deg,#5AC8FA,#3AAEE0)' },
    { name: 'pink',   bg: 'linear-gradient(135deg,#FF6B9D,#E0527F)' },
    { name: 'brown',  bg: 'linear-gradient(135deg,#A2845E,#8B7040)' },
    { name: 'yellow', bg: 'linear-gradient(135deg,#FFD60A,#E5C000)' },
];

const RED_BG = 'linear-gradient(135deg,#FF2D55,#E01040)';

// ── BFS Solver ──────────────────────────────────────────────────────
// State is encoded as a string of car positions: "row,col;row,col;..."
// Each car's position is its top-left cell.

function encodeState(cars) {
    return cars.map(c => `${c.row},${c.col}`).join(';');
}

function isSolved(cars) {
    // Red car (index 0) is horizontal length 2, needs col=4 to exit (occupies 4,5)
    return cars[0].col === 4;
}

function cloneCars(cars) {
    return cars.map(c => ({ ...c }));
}

function buildGrid(cars) {
    const g = Array(6).fill(null).map(() => Array(6).fill(-1));
    for (let i = 0; i < cars.length; i++) {
        const c = cars[i];
        for (let s = 0; s < c.length; s++) {
            const r = c.isHorizontal ? c.row : c.row + s;
            const col = c.isHorizontal ? c.col + s : c.col;
            if (r < 6 && col < 6) g[r][col] = i;
        }
    }
    return g;
}

function solve(carsInput, maxStates = 80000) {
    const cars = cloneCars(carsInput);
    const startKey = encodeState(cars);
    if (isSolved(cars)) return 0;

    const visited = new Set([startKey]);
    const queue = [{ cars: cloneCars(cars), moves: 0 }];

    while (queue.length > 0 && visited.size < maxStates) {
        const { cars: currentCars, moves } = queue.shift();
        const grid = buildGrid(currentCars);

        for (let i = 0; i < currentCars.length; i++) {
            const car = currentCars[i];

            if (car.isHorizontal) {
                // Try moving left
                for (let d = 1; d <= car.col; d++) {
                    const nc = car.col - d;
                    if (grid[car.row][nc] !== -1) break;
                    const newCars = cloneCars(currentCars);
                    newCars[i].col = nc;
                    const key = encodeState(newCars);
                    if (!visited.has(key)) {
                        if (isSolved(newCars)) return moves + 1;
                        visited.add(key);
                        queue.push({ cars: newCars, moves: moves + 1 });
                    }
                }
                // Try moving right
                for (let d = 1; car.col + car.length - 1 + d < 6; d++) {
                    const nc = car.col + car.length - 1 + d;
                    if (grid[car.row][nc] !== -1) break;
                    const newCars = cloneCars(currentCars);
                    newCars[i].col = car.col + d;
                    const key = encodeState(newCars);
                    if (!visited.has(key)) {
                        if (isSolved(newCars)) return moves + 1;
                        visited.add(key);
                        queue.push({ cars: newCars, moves: moves + 1 });
                    }
                }
            } else {
                // Try moving up
                for (let d = 1; d <= car.row; d++) {
                    const nr = car.row - d;
                    if (grid[nr][car.col] !== -1) break;
                    const newCars = cloneCars(currentCars);
                    newCars[i].row = nr;
                    const key = encodeState(newCars);
                    if (!visited.has(key)) {
                        if (isSolved(newCars)) return moves + 1;
                        visited.add(key);
                        queue.push({ cars: newCars, moves: moves + 1 });
                    }
                }
                // Try moving down
                for (let d = 1; car.row + car.length - 1 + d < 6; d++) {
                    const nr = car.row + car.length - 1 + d;
                    if (grid[nr][car.col] !== -1) break;
                    const newCars = cloneCars(currentCars);
                    newCars[i].row = car.row + d;
                    const key = encodeState(newCars);
                    if (!visited.has(key)) {
                        if (isSolved(newCars)) return moves + 1;
                        visited.add(key);
                        queue.push({ cars: newCars, moves: moves + 1 });
                    }
                }
            }
        }
    }

    return -1; // unsolvable within limit
}

// ── Puzzle generator ────────────────────────────────────────────────

function getConfig() {
    const smallCars = parseInt(document.getElementById('smallCars').value) || 8;
    const bigCars = parseInt(document.getElementById('bigCars').value) || 4;
    return {
        targetSmall: Math.max(0, Math.min(12, smallCars)),
        targetBig: Math.max(0, Math.min(8, bigCars))
    };
}

function tryGenerate(config) {
    const { targetSmall, targetBig } = config;
    const grid = Array(6).fill(null).map(() => Array(6).fill(-1));
    const cars = [];

    function place(id, row, col, len, horiz) {
        const car = { id, row, col, length: len, isHorizontal: horiz };
        const idx = cars.length;
        if (horiz) {
            if (col + len > 6) return false;
            for (let c = col; c < col + len; c++) { if (grid[row][c] !== -1) return false; }
            for (let c = col; c < col + len; c++) { grid[row][c] = idx; }
        } else {
            if (row + len > 6) return false;
            for (let r = row; r < row + len; r++) { if (grid[r][col] !== -1) return false; }
            for (let r = row; r < row + len; r++) { grid[r][col] = idx; }
        }
        cars.push(car);
        return true;
    }

    // Red car: row 2 (3rd row, 0-indexed), horizontal, length 2
    // Place at col 0 or 1 (further from exit = generally harder)
    const redCol = Math.floor(Math.random() * 2); // 0 or 1
    place('RED', 2, redCol, 2, true);

    // Place 2-3 vertical blockers crossing row 2 to the right of the red car
    const rightOfRed = redCol + 2;
    const availCols = [];
    for (let c = rightOfRed; c < 6; c++) availCols.push(c);
    // Shuffle available columns
    for (let i = availCols.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [availCols[i], availCols[j]] = [availCols[j], availCols[i]];
    }

    let blockersPlaced = 0;
    const maxBlockers = Math.min(3, targetSmall + targetBig);
    const targetBlockers = Math.min(maxBlockers, 2 + Math.floor(Math.random() * 2)); // 2 or 3
    let twoCount = 0;
    let threeCount = 0;

    for (const bCol of availCols) {
        if (blockersPlaced >= targetBlockers) break;
        // Prefer the type we have more of for blockers
        const preferSmall = (targetSmall - twoCount) > (targetBig - threeCount);
        const bLen = preferSmall ? 2 : 3;
        if ((bLen === 2 && twoCount >= targetSmall) || (bLen === 3 && threeCount >= targetBig)) continue;

        // Start row must make the car cross row 2
        const possibleStarts = [];
        for (let r = 0; r <= 6 - bLen; r++) {
            if (r <= 2 && r + bLen - 1 >= 2) possibleStarts.push(r);
        }
        if (possibleStarts.length === 0) continue;
        const bRow = possibleStarts[Math.floor(Math.random() * possibleStarts.length)];
        if (place('BLK', bRow, bCol, bLen, false)) {
            blockersPlaced++;
            if (bLen === 2) twoCount++; else threeCount++;
        }
    }

    let totalAttempts = 0;

    // Fill remaining 2-bar (small) cars up to target
    while (twoCount < targetSmall && totalAttempts < 400) {
        const horiz = Math.random() < 0.5;
        const r = Math.floor(Math.random() * 6);
        const c = Math.floor(Math.random() * 6);
        if (place(`S${twoCount + 1}`, r, c, 2, horiz)) {
            twoCount++;
        }
        totalAttempts++;
    }

    // Fill remaining 3-bar (big) cars up to target
    while (threeCount < targetBig && totalAttempts < 800) {
        const horiz = Math.random() < 0.5;
        const r = Math.floor(Math.random() * 6);
        const c = Math.floor(Math.random() * 6);
        if (place(`T${threeCount + 1}`, r, c, 3, horiz)) {
            threeCount++;
        }
        totalAttempts++;
    }

    // Need at least some cars placed (relaxed requirement based on user config)
    const minSmall = Math.min(2, targetSmall);
    const minBig = Math.min(1, targetBig);
    if (twoCount < minSmall || threeCount < minBig) return null;

    return cars;
}

function generateOnePuzzle(config) {
    let best = null;

    for (let i = 0; i < 300; i++) {
        const cars = tryGenerate(config);
        if (!cars) continue;

        const moves = solve(cars);
        if (moves < 4) continue; // skip trivial

        if (!best || moves > best.moves) {
            best = { cars, moves };
            // If we found a hard enough puzzle, stop early
            if (moves >= 12) break;
        }
    }

    return best;
}

// ── Rendering ───────────────────────────────────────────────────────

function renderCard(puzzle, cardNum) {
    const { cars, moves } = puzzle;

    let diffClass, diffLabel;
    if (moves <= 8) { diffClass = 'easy'; diffLabel = 'Easy'; }
    else if (moves <= 16) { diffClass = 'medium'; diffLabel = 'Medium'; }
    else { diffClass = 'hard'; diffLabel = 'Hard'; }

    // Assign colors (skip index 0 = red car)
    const palette = [...PALETTE].sort(() => Math.random() - 0.5);
    const carColors = ['__red__']; // index 0 = red
    for (let i = 1; i < cars.length; i++) {
        carColors.push(palette[(i - 1) % palette.length].bg);
    }
    const carSwatches = ['#FF2D55'];
    for (let i = 1; i < cars.length; i++) {
        // Extract first color from gradient for swatch
        const match = palette[(i - 1) % palette.length].bg.match(/#[0-9A-Fa-f]{6}/);
        carSwatches.push(match ? match[0] : '#999');
    }

    // Build labels
    const labels = ['RED'];
    let sIdx = 1, tIdx = 1;
    for (let i = 1; i < cars.length; i++) {
        if (cars[i].length === 2) labels.push(`S${sIdx++}`);
        else labels.push(`T${tIdx++}`);
    }

    const card = document.createElement('div');
    card.className = 'puzzle-card';

    // Header
    card.innerHTML = `
        <div class="card-header">
            <div class="puzzle-number">#${cardNum}</div>
            <div class="difficulty ${diffClass}">${diffLabel}</div>
        </div>
        <div class="grid-wrapper">
            <div class="grid-board">
                <div class="grid-inner"></div>
            </div>
            <div class="exit-arrow"></div>
        </div>
        <div class="moves-info">Min. moves: ${moves}</div>
        <div class="legend">
            <div class="legend-title">Move RED car to exit &rarr;</div>
            <div class="legend-items"></div>
        </div>
    `;

    const gridInner = card.querySelector('.grid-inner');

    // Draw 36 cells
    for (let i = 0; i < 36; i++) {
        const cell = document.createElement('div');
        cell.className = 'grid-cell';
        gridInner.appendChild(cell);
    }

    // Draw cars as absolutely positioned elements inside grid-inner
    // Each cell is 1/6 of the container. Gap is 2px.
    // We need to calculate positions relative to grid-inner.
    // grid-inner has gap:2px, so each cell width = (totalWidth - 5*2px) / 6
    // It's easier to use percentage + small offset for gaps.
    // Since gap is tiny (2px) relative to container, we use calc-based positioning.

    cars.forEach((car, i) => {
        const div = document.createElement('div');
        div.className = 'car' + (i === 0 ? ' car-red' : '');

        const gapPx = 2;
        // Use percentage for positioning: each cell slot is (100%/6)
        // But we need to account for gaps. With CSS grid gap, the grid handles it.
        // We'll overlay on top of the grid using percentages that match the grid layout.
        // For a 6-col grid with 2px gaps: cell-width ≈ calc((100% - 10px) / 6)
        // Position of col c: calc(c * (100% - 10px) / 6 + c * 2px)

        const cellW = `((100% - 10px) / 6)`;
        const cellH = `((100% - 10px) / 6)`;

        const left = `calc(${car.col} * ${cellW} + ${car.col * gapPx}px)`;
        const top = `calc(${car.row} * ${cellH} + ${car.row * gapPx}px)`;

        let width, height;
        if (car.isHorizontal) {
            width = `calc(${car.length} * ${cellW} + ${(car.length - 1) * gapPx}px)`;
            height = `calc(${cellH})`;
        } else {
            width = `calc(${cellW})`;
            height = `calc(${car.length} * ${cellH} + ${(car.length - 1) * gapPx}px)`;
        }

        div.style.left = left;
        div.style.top = top;
        div.style.width = width;
        div.style.height = height;

        if (i === 0) {
            div.style.background = RED_BG;
            div.textContent = 'RED';
        } else {
            div.style.background = carColors[i];
            div.textContent = labels[i];
        }

        gridInner.appendChild(div);
    });

    // Legend
    const legendItems = card.querySelector('.legend-items');
    cars.forEach((car, i) => {
        const item = document.createElement('div');
        item.className = 'legend-item';
        item.innerHTML = `<div class="legend-swatch" style="background:${carSwatches[i]}"></div><span>${labels[i]} (${car.length === 2 ? '2' : '3'})</span>`;
        legendItems.appendChild(item);
    });

    return card;
}

function generatePuzzles() {
    const container = document.getElementById('cardsGrid');
    container.innerHTML = '<div class="generating-msg">Generating solvable puzzles...</div>';

    // Use setTimeout so the "generating" message renders
    setTimeout(() => {
        const config = getConfig();
        const cards = [];
        for (let i = 0; i < 4; i++) {
            const puzzle = generateOnePuzzle(config);
            if (puzzle) cards.push(puzzle);
        }

        container.innerHTML = '';
        if (cards.length === 0) {
            container.innerHTML = '<div class="generating-msg">Could not generate puzzles. Try again!</div>';
            return;
        }

        cards.forEach((puzzle, i) => {
            container.appendChild(renderCard(puzzle, i + 1));
        });
    }, 50);
}

// Initial generation
generatePuzzles();
</script>
</body>
</html>
